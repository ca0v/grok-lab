<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimum-scale=1.0">

    <title>Tank Memory Maze</title>
    <style>
        :root {
            --grid-bg: #fff;
            --textColor: #000;
            /* Default black text */
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --grid-bg: #333;
                --textColor: #fff;
                /* White text in dark mode */
            }
        }

        body {
            overflow: hidden;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: var(--grid-bg);
        }

        canvas {
            border: 1px solid black;
            margin: 10px;
            box-sizing: border-box;
            display: block;
        }

        #instructions {
            display: none;

            @media (max-width: 768px) {
                display: block;
            }

            user-select: none;
            pointer-events: none;
            position: absolute;
            bottom: 0;
            font-size: small;
            left: 0;
            right: 0;
            text-align: center;
            font-family: Arial,
            sans-serif;
            margin: 10px 20px;
            animation: fadeOut 30s ease forwards;
            color: red;
        }

        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            max-width: 90vw;
        }

        /* Landscape mode: Move controls to the right */
        @media (orientation: landscape) {
            body {
                flex-direction: row;
                justify-content: center;
                align-items: center;
            }

            canvas {
                margin-right: 0;
                /* Reduce right margin to fit controls */
            }

            #controls {
                flex-direction: column;
                /* Stack controls vertically on the right */
                max-width: 20vw;
                /* Limit width in landscape */
            }
        }

        /* Portrait mode: Keep controls below (default) */
        @media (orientation: portrait) {
            body {
                flex-direction: column;
            }

            #controls {
                max-width: 90vw;
                /* Full width below grid in portrait */
            }
        }

        .dpad-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .dpad-row {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .extra-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            font-size: 20px;
            font-family: Arial, sans-serif;
            background-color: #ccc;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            touch-action: none;
        }

        #shoot {
            width: 70px;
            height: 70px;
            font-size: 24px;
            background-color: #f00;
            color: white;
        }

        @keyframes fadeOut {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                display: none;
            }
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="instructions">Use WASD to move far, Arrow keys to move one cell, Space to shoot, X to place/move to marker,
        ? to peek numbers. Hit targets in order! Game over at 5 misses.</div>
    <div id="controls">
        <div class="dpad-container">
            <div class="dpad-row">
                <button class="control-btn" id="up">↑</button>
            </div>
            <div class="dpad-row">
                <button class="control-btn" id="left">←</button>
                <button class="control-btn" id="shoot">⍽</button>
                <button class="control-btn" id="right">→</button>
            </div>
            <div class="dpad-row">
                <button class="control-btn" id="down">↓</button>
            </div>
        </div>
        <div class="extra-buttons">
            <button class="control-btn" id="marker">M</button>
            <button class="control-btn" id="peek">P</button>
        </div>
    </div>
    <script>
        class MazeMemoryGame {
            // Configuration constants
            CONFIG = {
                MAZE_WALL_COLOR: 'gray',
                TANK_COLOR: 'green',
                BULLET_COLOR: 'red',
                POWER_UP_COLOR: 'yellow',
                TARGET_OUTLINE_COLOR: 'black',
                GRID_SIZE: 40,
                BANNER_HEIGHT_PERCENT: 0.11,
                CANVAS_MARGIN: { HORIZONTAL: 40, VERTICAL: 60 },
                MAX_MISSES: 5,
                BULLET_SPEED: 0.2,
                TANK_SPEED: 0.1,
                MIN_GRID_SIZE: 7,
                LEVELS_PER_CYCLE: 3,
                POWER_UP_DURATION: 10000,
                POWER_UP_REVEAL_DURATION: 1000,
                INITIAL_NUMBER_TIMER: 5000,
                GAME_OVER_DELAY: 3000,
                LEVEL_CLEAR_DELAY: 2000,
                CONTROLS_HEIGHT: 200,
                BULLET_SIZE: 5,
                TANK_RADIUS_OFFSET: 7,
                TARGET_RADIUS_SCALE: 0.8,
                TARGET_OUTLINE_WIDTH: 2,
                POWER_UP_RADIUS_SCALE: 0.25,
                FRAME_DELTA: 16,
                ROTATION_DURATION: 50,
                FLASH_DURATION: 1000,
                MAZE_SIZE_INCREMENT: 2,
                TARGETS_BASE: 3,
                TARGETS_PER_LEVEL: 3,
                SCOREBOARD_FONT_SCALE: 2.5,
                MESSAGE_FONT_SCALE: 20,
                MARKER_FONT_SIZE: 30,
                TANK_FONT_SIZE: 20
            };


            // Updated INPUT_MAP and handleInput from previous suggestion
            INPUT_MAP = {
                'w': { action: 'moveFar', dir: 'up' },
                's': { action: 'moveFar', dir: 'down' },
                'a': { action: 'moveFar', dir: 'left' },
                'd': { action: 'moveFar', dir: 'right' },
                'ArrowUp': { action: 'moveOne', dir: 'up' },
                'ArrowDown': { action: 'moveOne', dir: 'down' },
                'ArrowLeft': { action: 'moveOne', dir: 'left' },
                'ArrowRight': { action: 'moveOne', dir: 'right' },
                ' ': { action: 'shoot' },
                'x': { action: 'marker' },
                'm': { action: 'marker' },
                '?': { action: 'peek' },
                'p': { action: 'peek' },
                'up': { action: 'move', dir: 'up' },
                'down': { action: 'move', dir: 'down' },
                'left': { action: 'move', dir: 'left' },
                'right': { action: 'move', dir: 'right' },
                'shoot': { action: 'shoot' },
                'marker': { action: 'marker' },
                'peek': { action: 'peek' }
            };

            constructor() {
                this.initializeGameConstants();
                this.initializeCanvas();
                this.initializeGameState();
                this.initializeEventHandlers();
                this.resetLevel();
                this.setupInputHandlers();
                window.addEventListener('resize', () => this.updateCanvasSize());
                this.gameLoop();
            }

            initializeGameConstants() {
                this.mazeSize = this.CONFIG.MIN_GRID_SIZE;
                this.level = 0;
                this.maxTargets = this.CONFIG.TARGETS_BASE;
            }

            initializeCanvas() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = this.CONFIG.GRID_SIZE;
                this.controlsHeight = this.CONFIG.CONTROLS_HEIGHT;
                this.topBorderSize = 0;
                this.updateCanvasSize();
            }

            initializeGameState() {
                this.maze = [];
                this.tank = this.createTank(0, 0);
                this.targets = [];
                this.bullets = [];
                this.powerUp = null;
                this.powerUpTimer = 0;
                this.currentTarget = 1;
                this.showNumbers = true;
                this.numberTimer = this.CONFIG.INITIAL_NUMBER_TIMER;
                this.keysPressed = {};
                this.score = { hits: 0, lives: this.CONFIG.MAX_MISSES, total: 0, moves: 0 }; // Add moves
                this.gameOverDelay = 0;
                this.marker = null;
                this.gameOver = false;
                this.levelCleared = false;
                this.targetColors = [];
                this.colorIndex = 0;
                this.lastButtonDirection = null;
                this.showAllTimer = 0;
                this.showNextTimer = 0;
            }

            createTank(x, y) {
                return {
                    x, y,
                    dir: 'right',
                    currentAngle: 0,
                    targetAngle: 0,
                    rotationStart: null,
                    desiredX: x,
                    desiredY: y,
                    desiredDir: 'right',
                    ignoreCollisions: false
                };
            }

            initializeEventHandlers() {
                this.eventHandlers = {
                    hit: () => {
                        this.score.hits++;
                        this.currentTarget++;
                        this.showAllTimer = this.powerUpTimer > 0 ? this.CONFIG.POWER_UP_REVEAL_DURATION : 0;
                    },
                    miss: (target) => {
                        if (target) target.flashTimer = this.CONFIG.FLASH_DURATION;
                        this.showAllTimer = this.powerUpTimer > 0 ? this.CONFIG.POWER_UP_REVEAL_DURATION : 0;
                        this.score.lives--;
                    }
                };
            }

            resetLevel() {
                if (this.gameOver) return;
                const levelCycle = this.level % this.CONFIG.LEVELS_PER_CYCLE;
                const difficulty = Math.floor(this.level / this.CONFIG.LEVELS_PER_CYCLE);
                this.mazeSize = this.CONFIG.MIN_GRID_SIZE + (difficulty + levelCycle) * this.CONFIG.MAZE_SIZE_INCREMENT;
                this.updateCanvasSize();
                this.maxTargets = this.CONFIG.TARGETS_BASE + Math.floor(this.level / this.CONFIG.TARGETS_PER_LEVEL);

                this.maze = this.generateMaze();
                const startPos = this.getRandomOpenPosition();

                this.tank = this.createTank(startPos.x, startPos.y);
                this.targets = [];
                this.assignTargetColors();
                for (let i = 1; i <= this.maxTargets; i++) {
                    let pos;
                    do {
                        pos = this.getRandomOpenPosition();
                    } while (this.targets.some(t => t.x === pos.x && t.y === pos.y) || (pos.x === this.tank.x && pos.y === this.tank.y));
                    this.targets.push({ x: pos.x, y: pos.y, num: i, hit: false, flashTimer: 0, color: this.targetColors[i - 1] });
                }
                this.bullets = [];
                this.powerUp = this.getRandomOpenPosition();
                this.currentTarget = 1;
                this.showNumbers = true;
                this.numberTimer = this.CONFIG.INITIAL_NUMBER_TIMER;
                this.marker = null;
                if (this.level === 0) {
                    this.score.lives = this.CONFIG.MAX_MISSES;
                } else if (this.levelCleared) {
                    this.score.lives = Math.min(this.score.lives + 1, this.CONFIG.MAX_MISSES);
                }
                if (this.level > 0) {
                    const moveBonus = Math.max(0, 100 - this.score.moves * 2); // Bonus: 100 points minus 2 per move
                    this.score.total += this.score.hits * this.score.lives + moveBonus;
                }
                this.score.moves = 0; // Reset after scoring
                this.levelCleared = false;
                this.level++;
            }

            setupInputHandlers() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver || this.levelCleared) return;
                    if (this.keysPressed[e.key]) return;
                    this.keysPressed[e.key] = true;

                    const input = this.INPUT_MAP[e.key.toLowerCase()] || this.INPUT_MAP[e.key];
                    if (input) {
                        e.preventDefault();
                        if (this.showNumbers && this.numberTimer > 0 && input.action !== 'shoot') {
                            this.showNumbers = false;
                            this.numberTimer = 0;
                            return;
                        }
                        this.handleInput(input);
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keysPressed[e.key] = false;
                });

                Object.keys(this.INPUT_MAP).forEach(id => {
                    const button = document.getElementById(id);
                    if (button) {
                        const handleStart = (e) => {
                            if (this.gameOver || this.levelCleared) return;
                            e.preventDefault();
                            if (this.showNumbers && this.numberTimer > 0 && this.INPUT_MAP[id].action !== 'shoot') {
                                this.showNumbers = false;
                                this.numberTimer = 0;
                                return;
                            }
                            this.handleInput(this.INPUT_MAP[id]);
                        };
                        button.addEventListener('mousedown', handleStart);
                        button.addEventListener('touchstart', handleStart);
                        button.addEventListener('mouseup', (e) => e.preventDefault());
                        button.addEventListener('touchend', (e) => e.preventDefault());
                    }
                });
            }

            handleInput(input) {
                switch (input.action) {
                    case 'moveFar': {
                        const pos = this.moveFar(Math.round(this.tank.x), Math.round(this.tank.y), input.dir);
                        this.tank.desiredX = pos.x;
                        this.tank.desiredY = pos.y < this.mazeSize - 1 ? pos.y : this.tank.y;
                        this.tank.desiredDir = input.dir;
                        this.tank.ignoreCollisions = false;
                        this.updateTankDirection(input.dir);
                        this.score.moves++; // Count as a move
                        break;
                    }
                    case 'moveOne': {
                        if (this.tank.dir === input.dir) {
                            const dx = input.dir === 'right' ? 1 : input.dir === 'left' ? -1 : 0;
                            const dy = input.dir === 'down' ? 1 : input.dir === 'up' ? -1 : 0;
                            const newX = this.tank.x + dx;
                            const newY = this.tank.y + dy;
                            if (
                                newX >= 0 && newX < this.mazeSize &&
                                newY >= 0 && newY < this.mazeSize &&
                                this.maze[Math.floor(newY)][Math.floor(newX)] === 0
                            ) {
                                this.tank.desiredX = newX;
                                this.tank.desiredY = newY;
                                this.tank.ignoreCollisions = false;
                                this.score.moves++; // Count as a move
                            }
                        }
                        this.updateTankDirection(input.dir);
                        break;
                    }
                    case 'move': {
                        if (this.tank.dir !== input.dir) {
                            this.updateTankDirection(input.dir);
                            this.lastButtonDirection = input.dir;
                        } else if (this.lastButtonDirection === input.dir) {
                            const pos = this.moveFar(Math.round(this.tank.x), Math.round(this.tank.y), input.dir);
                            this.tank.desiredX = pos.x;
                            this.tank.desiredY = pos.y < this.mazeSize - 1 ? pos.y : this.tank.y;
                            this.tank.desiredDir = input.dir;
                            this.tank.ignoreCollisions = false;
                            this.score.moves++; // Count as a move
                        }
                        break;
                    }
                    case 'shoot': {
                        let bullet = { x: this.tank.x + 0.5, y: this.tank.y + 0.5, dir: this.tank.dir };
                        if (!this.checkBulletCollision(bullet)) {
                            this.bullets.push(bullet);
                        }
                        break;
                    }
                    case 'marker': {
                        if (!this.marker) {
                            this.marker = { x: Math.round(this.tank.x), y: Math.round(this.tank.y) };
                        } else {
                            this.tank.desiredX = this.marker.x;
                            this.tank.desiredY = this.marker.y;
                            this.tank.ignoreCollisions = true;
                            this.marker = null;
                            this.score.moves++; // Count as a move
                        }
                        break;
                    }
                    case 'peek': {
                        this.showNextTimer = this.CONFIG.FLASH_DURATION;
                        this.score.lives--;
                        break;
                    }
                }
            }

            updateTankDirection(newDir) {
                if (this.tank.dir !== newDir) {
                    this.tank.dir = newDir;
                    this.tank.desiredDir = newDir;
                    this.tank.rotationStart = performance.now();
                    this.score.moves++; // Count rotation as a move
                    switch (newDir) {
                        case 'up': this.tank.targetAngle = -Math.PI / 2; break;
                        case 'down': this.tank.targetAngle = Math.PI / 2; break;
                        case 'left': this.tank.targetAngle = Math.PI; break;
                        case 'right': this.tank.targetAngle = 0; break;
                    }
                }
            }

            updateCanvasSize() {
                const windowWidth = window.innerWidth - this.CONFIG.CANVAS_MARGIN.HORIZONTAL; // Fixed
                const windowHeight = window.innerHeight - this.CONFIG.CANVAS_MARGIN.VERTICAL - this.controlsHeight; // Fixed
                const maxSize = Math.min(windowWidth, windowHeight); // Limit by minimum of width and adjusted height
                this.canvas.width = maxSize;
                this.bannerHeight = maxSize * this.CONFIG.BANNER_HEIGHT_PERCENT; // Fixed
                this.canvas.height = maxSize + this.bannerHeight;
                this.gridSize = Math.floor(maxSize / this.mazeSize);
                this.topBorderSize = this.gridSize; // Set top border to match one row
            }

            generateMaze() {
                const size = this.mazeSize;
                const maze = Array(size).fill().map(() => Array(size).fill(1));
                const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                const shuffle = (array) => {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                };
                const carve = (x, y) => {
                    maze[y][x] = 0;
                    const dirs = directions.slice();
                    shuffle(dirs);
                    for (let [dy, dx] of dirs) {
                        const newY = y + dy;
                        const newX = x + dx;
                        if (newY > 0 && newY < size - 1 && newX > 0 && newX < size - 1 && maze[newY][newX] === 1) {
                            maze[y + dy / 2][x + dx / 2] = 0;
                            carve(newX, newY);
                        }
                    }
                };
                carve(1, 1);
                for (let x = 0; x < size; x++) {
                    maze[size - 1][x] = 1; // Solid bottom row
                }
                return maze;
            }

            getRandomOpenPosition() {
                let x, y;
                do {
                    x = Math.floor(Math.random() * this.mazeSize);
                    y = Math.floor(Math.random() * (this.mazeSize - 1)); // Exclude bottom row
                } while (this.maze[y][x] !== 0);
                return { x, y };
            }

            getRandomColor() {
                const niceColors = [
                    '#8B4513', // Saddle Brown
                    '#483D8B', // Dark Slate Blue
                    '#A52A2A', // Brown
                    '#4B0082', // Indigo
                    '#8A2BE2', // Blue Violet
                    '#9932CC', // Dark Orchid
                    '#800080', // Purple
                    '#B22222', // Firebrick
                    '#4682B4', // Steel Blue
                    '#191970', // Midnight Blue
                    '#9B30FF', // Purple (brighter)
                    '#CD5C5C', // Indian Red
                    '#9400D3', // Dark Violet
                    '#FF4500', // Orange Red
                    '#8B0000', // Dark Red
                    '#4169E1', // Royal Blue
                    '#C71585', // Medium Violet Red
                    '#00008B', // Dark Blue
                    '#DC143C', // Crimson
                    '#6A5ACD', // Slate Blue
                    '#FF6347', // Tomato
                    '#7B68EE', // Medium Slate Blue
                    '#DAA520', // Goldenrod
                    '#BA55D3'  // Medium Orchid
                ];
                const color = niceColors[this.colorIndex % niceColors.length];
                this.colorIndex++;
                return color;
            }

            assignTargetColors() {
                this.targetColors = [];
                for (let i = 1; i <= this.maxTargets; i++) {
                    this.targetColors[i - 1] = this.getRandomColor();
                }
            }

            moveFar(x, y, dir) {
                let newX = x, newY = y;
                let fromDir;
                switch (dir) {
                    case 'up': fromDir = 'down'; break;
                    case 'down': fromDir = 'up'; break;
                    case 'left': fromDir = 'right'; break;
                    case 'right': fromDir = 'left'; break;
                }
                while (true) {
                    const nextX = newX + (dir === 'right' ? 1 : dir === 'left' ? -1 : 0);
                    const nextY = newY + (dir === 'down' ? 1 : dir === 'up' ? -1 : 0);
                    if (nextX < 0 || nextX >= this.mazeSize || nextY < 0 || nextY >= this.mazeSize || this.maze[nextY][nextX] === 1) {
                        break;
                    }
                    newX = nextX;
                    newY = nextY;
                    if (this.isIntersection(newX, newY, fromDir)) {
                        break;
                    }
                }
                return { x: newX, y: newY };
            }

            isIntersection(x, y, fromDir) {
                const directions = [
                    { dx: 0, dy: -1, dir: 'up' },
                    { dx: 0, dy: 1, dir: 'down' },
                    { dx: -1, dy: 0, dir: 'left' },
                    { dx: 1, dy: 0, dir: 'right' }
                ];
                let openPaths = 0;
                directions.forEach(d => {
                    const newX = x + d.dx;
                    const newY = y + d.dy;
                    if (newX >= 0 && newX < this.mazeSize && newY >= 0 && newY < this.mazeSize && this.maze[newY][newX] === 0 && d.dir !== fromDir) {
                        openPaths++;
                    }
                });
                return openPaths > 1;
            }

            checkBulletCollision(bullet) {
                let hitTarget = false;
                const bulletGridX = Math.floor(bullet.x);
                const bulletGridY = Math.floor(bullet.y);

                // Check for correct target hit first
                for (const t of this.targets) {
                    if (!t.hit && bulletGridX === t.x && bulletGridY === t.y && t.num === this.currentTarget) {
                        t.hit = true;
                        this.eventHandlers.hit();
                        return true;
                    }
                }

                // Check for incorrect target hit or wall
                this.targets.forEach(t => {
                    if (!t.hit && bulletGridX === t.x && bulletGridY === t.y) {
                        hitTarget = true;
                        this.eventHandlers.miss(t);
                    }
                });

                // Check for power-up hit
                if (this.powerUp && bulletGridX === this.powerUp.x && bulletGridY === this.powerUp.y) {
                    this.powerUpTimer = this.CONFIG.POWER_UP_DURATION;
                    this.powerUp = null; // Remove power-up after hit
                    hitTarget = true; // Bullet stops here
                }

                if (!hitTarget) {
                    if (bulletGridX >= 0 && bulletGridX < this.mazeSize && bulletGridY >= 0 && bulletGridY < this.mazeSize) {
                        if (this.maze[bulletGridY][bulletGridX] === 1) {
                            this.maze[bulletGridY][bulletGridX] = 0;
                            this.eventHandlers.miss();
                            hitTarget = true;
                        }
                    } else {
                        this.eventHandlers.miss();
                        hitTarget = true;
                    }
                }
                return hitTarget;
            }

            update() {
                if (this.levelCleared) return; // Only return for level cleared, not game over

                if (this.showNumbers && this.numberTimer > 0) {
                    this.numberTimer -= this.CONFIG.FRAME_DELTA;
                    if (this.numberTimer <= 0) this.showNumbers = false;
                    return;
                }

                const tankGridX = Math.floor(this.tank.x);
                const tankGridY = Math.floor(this.tank.y);

                if (this.powerUpTimer > 0) {
                    this.powerUpTimer -= this.CONFIG.FRAME_DELTA;
                    if (this.powerUpTimer < 0) this.powerUpTimer = 0;
                }

                if (this.showAllTimer > 0) {
                    this.showAllTimer -= this.CONFIG.FRAME_DELTA;
                    if (this.showAllTimer < 0) this.showAllTimer = 0;
                }

                if (this.showNextTimer > 0) {
                    this.showNextTimer -= this.CONFIG.FRAME_DELTA;
                    if (this.showNextTimer < 0) this.showNextTimer = 0;
                }

                if (!this.gameOver) { // Only update tank movement if not game over
                    if (this.tank.x !== this.tank.desiredX || this.tank.y !== this.tank.desiredY) {
                        const dx = this.tank.desiredX - this.tank.x;
                        const dy = this.tank.desiredY - this.tank.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > this.CONFIG.TANK_SPEED && distance > 0) {
                            const moveX = (dx / distance) * this.CONFIG.TANK_SPEED;
                            const moveY = (dy / distance) * this.CONFIG.TANK_SPEED;
                            const nextX = this.tank.x + moveX;
                            const nextY = this.tank.y + moveY;
                            const startGridX = Math.floor(this.tank.x);
                            const startGridY = Math.floor(this.tank.y);
                            const endGridX = Math.floor(nextX);
                            const endGridY = Math.floor(nextY);

                            if (this.tank.ignoreCollisions) {
                                this.tank.x = nextX;
                                this.tank.y = nextY;
                            } else {
                                if (startGridX !== endGridX || startGridY !== endGridY) {
                                    if (endGridX >= 0 && endGridX < this.mazeSize && endGridY >= 0 && endGridY < this.mazeSize && this.maze[endGridY][endGridX] === 0) {
                                        this.tank.x = nextX;
                                        this.tank.y = nextY;
                                    } else {
                                        if (startGridX !== endGridX) {
                                            this.tank.x = endGridX > startGridX ? startGridX + 1 - 0.001 : startGridX - 0.001;
                                        }
                                        if (startGridY !== endGridY) {
                                            this.tank.y = endGridY > startGridY ? startGridY + 1 - 0.001 : startGridY - 0.001;
                                        }
                                        this.tank.desiredX = this.tank.x;
                                        this.tank.desiredY = this.tank.y;
                                    }
                                } else {
                                    this.tank.x = nextX;
                                    this.tank.y = nextY;
                                }
                            }
                        } else {
                            this.tank.x = this.tank.desiredX;
                            this.tank.y = this.tank.desiredY;
                            this.tank.ignoreCollisions = false;
                        }
                    }

                    if (this.tank.rotationStart !== null) {
                        const elapsed = performance.now() - this.tank.rotationStart;
                        if (elapsed < this.CONFIG.ROTATION_DURATION) {
                            const progress = elapsed / this.CONFIG.ROTATION_DURATION;
                            this.tank.currentAngle += (this.tank.targetAngle - this.tank.currentAngle) * progress;
                        } else {
                            this.tank.currentAngle = this.tank.targetAngle;
                            this.tank.rotationStart = null;
                        }
                    }

                    this.targets.forEach(t => {
                        if (t.flashTimer > 0) {
                            t.flashTimer -= this.CONFIG.FRAME_DELTA;
                            if (t.flashTimer < 0) t.flashTimer = 0;
                        }
                    });

                    this.bullets = this.bullets.filter(b => {
                        switch (b.dir) {
                            case 'up': b.y -= this.CONFIG.BULLET_SPEED; break;
                            case 'down': b.y += this.CONFIG.BULLET_SPEED; break;
                            case 'left': b.x -= this.CONFIG.BULLET_SPEED; break;
                            case 'right': b.x += this.CONFIG.BULLET_SPEED; break;
                        }
                        return !this.checkBulletCollision(b);
                    });
                }

                // Handle game over restart regardless of gameOver state
                if (this.score.lives <= 0) {
                    if (!this.gameOver) {
                        this.gameOver = true;
                        this.gameOverDelay = this.CONFIG.GAME_OVER_DELAY;
                    }
                    this.gameOverDelay -= this.CONFIG.FRAME_DELTA;
                    if (this.gameOverDelay <= 0) {
                        this.gameOver = false;
                        this.score.lives = this.CONFIG.MAX_MISSES; // Reset lives to 5
                        this.resetLevel();
                    }
                } else if (this.targets.every(t => t.hit)) {
                    this.levelCleared = true;
                    setTimeout(() => this.resetLevel(), this.CONFIG.LEVEL_CLEAR_DELAY);
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawMaze(); // No need for isDarkMode parameter
                this.drawTargets();
                this.drawPowerUp();
                this.drawMarker(getComputedStyle(document.documentElement).getPropertyValue('--grid-bg') === '#333' ? '#fff' : '#000');
                this.drawTank();
                this.drawBullets();
                this.drawScoreboard(getComputedStyle(document.documentElement).getPropertyValue('--grid-bg') === '#333');
                this.drawMessages();
            }

            drawMaze() {
                const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--grid-bg').trim();
                for (let y = 0; y < this.mazeSize; y++) {
                    for (let x = 0; x < this.mazeSize; x++) {
                        this.ctx.fillStyle = this.maze[y][x] === 1 ? this.CONFIG.MAZE_WALL_COLOR : bgColor;
                        this.ctx.fillRect(x * this.gridSize, y * this.gridSize + this.topBorderSize, this.gridSize, this.gridSize);
                    }
                }
            }

            drawTargets() {
                this.targets.forEach(t => {
                    if (!t.hit) {
                        const targetRadius = (this.gridSize / 2) * this.CONFIG.TARGET_RADIUS_SCALE;
                        this.ctx.fillStyle = this.CONFIG.TARGET_OUTLINE_COLOR;
                        this.ctx.beginPath();
                        this.ctx.arc(t.x * this.gridSize + this.gridSize / 2, t.y * this.gridSize + this.gridSize / 2 + this.topBorderSize, targetRadius + 2, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.fillStyle = t.color;
                        this.ctx.beginPath();
                        this.ctx.arc(t.x * this.gridSize + this.gridSize / 2, t.y * this.gridSize + this.gridSize / 2 + this.topBorderSize, targetRadius, 0, Math.PI * 2);
                        this.ctx.fill();

                        if (this.showNumbers || t.flashTimer > 0 || this.showAllTimer > 0 || (t.num === this.currentTarget && this.showNextTimer > 0)) {
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = `${Math.floor(targetRadius)}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(t.num, t.x * this.gridSize + this.gridSize / 2, t.y * this.gridSize + this.gridSize / 2 + this.topBorderSize);
                        }
                    }
                });
            }

            drawMarker(color) {
                if (this.marker) {
                    this.ctx.fillStyle = color;
                    this.ctx.font = `${this.CONFIG.MARKER_FONT_SIZE}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('📍', this.marker.x * this.gridSize + this.gridSize / 2, this.marker.y * this.gridSize + this.gridSize / 2 + this.topBorderSize);
                }
            }

            drawTank() {
                this.ctx.save();
                this.ctx.translate(this.tank.x * this.gridSize + this.gridSize / 2, this.tank.y * this.gridSize + this.gridSize / 2 + this.topBorderSize);
                this.ctx.fillStyle = this.CONFIG.TANK_COLOR;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, this.gridSize / 2 - this.CONFIG.TANK_RADIUS_OFFSET, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.rotate(this.tank.currentAngle);
                this.ctx.fillStyle = 'white';
                this.ctx.font = `${this.CONFIG.TANK_FONT_SIZE}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('➔', 0, 0);
                this.ctx.restore();
            }

            drawBullets() {
                this.ctx.fillStyle = this.CONFIG.BULLET_COLOR;
                this.bullets.forEach(b => {
                    this.ctx.fillRect(b.x * this.gridSize, b.y * this.gridSize + this.topBorderSize, this.CONFIG.BULLET_SIZE, this.CONFIG.BULLET_SIZE);
                });
            }

            drawPowerUp() {
                if (this.powerUp) {
                    this.ctx.fillStyle = this.CONFIG.POWER_UP_COLOR;
                    this.ctx.beginPath();
                    this.ctx.arc(
                        this.powerUp.x * this.gridSize + this.gridSize / 2,
                        this.powerUp.y * this.gridSize + this.gridSize / 2 + this.topBorderSize,
                        this.gridSize * this.CONFIG.POWER_UP_RADIUS_SCALE,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }
            }

            drawScoreboard(isDarkMode) {
                const fontSize = Math.floor(this.bannerHeight / this.CONFIG.SCOREBOARD_FONT_SCALE);
                this.ctx.fillStyle = isDarkMode ? '#222' : '#ddd';
                this.ctx.fillRect(0, 0, this.canvas.width, this.bannerHeight);
                this.ctx.font = `${fontSize}px Arial`;
                this.ctx.fillStyle = isDarkMode ? '#fff' : 'black';
                this.ctx.textBaseline = 'top';

                this.ctx.textAlign = 'left';
                this.ctx.fillText('Hits', 10, 10);
                this.ctx.fillStyle = isDarkMode ? '#ccc' : 'black';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.score.hits, 60, 10 + fontSize);

                this.ctx.fillStyle = isDarkMode ? '#fff' : 'black';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('Lives', this.canvas.width - 10, 10);
                this.ctx.fillStyle = 'green';
                const circleRadius = fontSize / 4;
                const circleSpacing = circleRadius * 3;
                // Adjusted startX to shift left and fit all circles
                const totalWidth = (this.score.lives - 1) * circleSpacing + 2 * circleRadius; // Full width of all circles
                const startX = this.canvas.width - 10 - totalWidth - circleRadius; // Align right edge with margin
                for (let i = 0; i < this.score.lives; i++) {
                    this.ctx.beginPath();
                    this.ctx.arc(startX + i * circleSpacing + circleRadius, 10 + fontSize + circleRadius, circleRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.ctx.fillStyle = isDarkMode ? '#fff' : 'black';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`Level: ${this.level}`, this.canvas.width / 2, 10);
                if (this.showNumbers && this.numberTimer > 0) {
                    const countdown = Math.ceil(this.numberTimer / 1000);
                    this.ctx.fillText(countdown, this.canvas.width / 2, 10 + fontSize);
                } else {
                    this.ctx.fillText(`Score: ${this.score.total}`, this.canvas.width / 2, 10 + fontSize);
                }
            }

            drawMessages() {
                if (this.levelCleared) {
                    this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--textColor').trim();
                    this.ctx.font = `${Math.floor(this.canvas.height / this.CONFIG.MESSAGE_FONT_SCALE)}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('Level Cleared! Starting New Level...', this.canvas.width / 2, this.canvas.height / 2);
                }

                if (this.gameOver) {
                    this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--textColor').trim();
                    this.ctx.font = `${Math.floor(this.canvas.height / this.CONFIG.MESSAGE_FONT_SCALE)}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('Game Over! Restarting...', this.canvas.width / 2, this.canvas.height / 2);
                }
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game
        new MazeMemoryGame();
    </script>
</body>

</html>